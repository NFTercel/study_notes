《使用Envoy来负载均衡gRPC流量》
-------------------------------------------

原文地址： https://blog.bugsnag.com/envoy/

发布日期：2018.01.10

Bugsnag为了减少延迟，选择将REST改为gRPC框架。

# 关于Bugsnag架构的一些背景

Bugsnag有一条微服务流水线，负责处理从客户接收到的错误并且随后展示在面板上。
该流水线目前每天处理几亿个事件。（hundreds of millions of events per day）
为了支持新发布的面板，我们需要扩展流水线。 性能是该项目的关键，也是我们接受gRPC框架的主要原因。

关于部署方面，Bugsnag的微服务在云上以Docker容器部署，使用了Google的优秀的Kubernetes编排工具。
Kubernetes内置了基于 kube-proxy 的负载均衡机制，它能够完美地配合HTTP/1.1使用，但是当你加入 HTTP/2 进去的时候事情就变得有趣了。

# HTTP/2－头疼的负载均衡
gRPC使用了性能更好的 HTTP/2 协议。L4（四层负载均衡）对它无效。
而k8s的kube-proxy本质上是一个L4负载均衡，所以无法用于gRPC调用的负载均衡。
为何不让客户端完成该项工作？
因为这会导致客户端最终变得脆弱易出错，并且需要大量自定义代码来提供弹性、性能监控或者日志信息，而这些需要为我们流水线的不同语言重复好几遍。

#选择一个更智能的负载均衡

我们需要7层负载均衡，更重要的是，要能支持 HTTP/2协议。 有很多不同的L7选项，包括Nginx和HAproxy，但是很多对于我们的微服务架构来说都太重量级了。
最终将目标锁定在两个竞争者上： Envoy和Linkerd。 两者都是为微服务架构开发的，且都支持gRPC。
尽管两者都有很多不错的功能特性，但是最终的选择落到了代理的影响上。 考虑到这一点，Envoy由于轻量级而明显胜出。 Envoy用C++11实现，没有基于Java的Linkerd的企业重量级。

# 是什么使得Envoy如此优秀？
Envoy由Lyft公司实现并开源，本身是多年处理复杂路由出现的产物。
它从本质设计上适合我们的问题：
- 对HTTP/2和SSL在任意方向上的一级支持
- 高透明度实现性能监控
- 成熟的文档集合
- 不依赖任何给定的语言
最后一点对于Bugsnag很重要。它和我们的多语言微服务保持一致。

# 将Envoy融入我们的架构
我们选择为我们的每个gRPC客户端运行一个Envoy sidecar， 但是像Lyft这样的公司是为他们的所有微服务都运行一个sidecar Envoy，形成服务网格。
这种方式很强有力，让你可以在域名层次调节通信参数，我们会在Bugsnag进行推广使用。

# 替代方案

尽管Envoy很好地满足我们的需求，但是还有一些值得一提的替代方案。我们探索了其中一些，但是他们要么太过于不成熟，要么不适合我们当前的架构：
- Istio
- Ribbon
- Kubernetes Ingress Controollers
总体来说，我们被Envoy所震撼并且会随着我们扩展Bugsnag继续探索它的特性。
